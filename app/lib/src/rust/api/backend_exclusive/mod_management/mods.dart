// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.21.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../../shared_resources/authentication/account.dart';
import '../../shared_resources/collection.dart';
import '../vanilla/version.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'mods.freezed.dart';

class MinecraftModData {
  final FerinthStructuresVersionVersion field0;

  const MinecraftModData({
    required this.field0,
  });

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MinecraftModData &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class ModManager {
  final List<ModMetadata> mods;
  final List<VersionMetadata>? cache;
  final PathBuf gameDirectory;
  final ModLoader? modLoader;
  final VersionMetadata targetGameVersion;

  const ModManager({
    required this.mods,
    this.cache,
    required this.gameDirectory,
    this.modLoader,
    required this.targetGameVersion,
  });

  @override
  int get hashCode =>
      mods.hashCode ^
      cache.hashCode ^
      gameDirectory.hashCode ^
      modLoader.hashCode ^
      targetGameVersion.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ModManager &&
          runtimeType == other.runtimeType &&
          mods == other.mods &&
          cache == other.cache &&
          gameDirectory == other.gameDirectory &&
          modLoader == other.modLoader &&
          targetGameVersion == other.targetGameVersion;
}

class ModMetadata {
  final String name;
  final String longDescription;
  final String shortDescription;
  final String modVersion;
  final List<Tag> tag;
  final List<ModOverride> overrides;
  final List<ModMetadata>? incompatiableMods;
  final MinecraftModData modData;

  const ModMetadata({
    required this.name,
    required this.longDescription,
    required this.shortDescription,
    required this.modVersion,
    required this.tag,
    required this.overrides,
    this.incompatiableMods,
    required this.modData,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      longDescription.hashCode ^
      shortDescription.hashCode ^
      modVersion.hashCode ^
      tag.hashCode ^
      overrides.hashCode ^
      incompatiableMods.hashCode ^
      modData.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ModMetadata &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          longDescription == other.longDescription &&
          shortDescription == other.shortDescription &&
          modVersion == other.modVersion &&
          tag == other.tag &&
          overrides == other.overrides &&
          incompatiableMods == other.incompatiableMods &&
          modData == other.modData;
}

/// `IgnoreMinorGameVersion` will behave like `IgnoreAllGameVersion` if operated on snapshots.
enum ModOverride {
  ignoreMinorGameVersion,
  ignoreAllGameVersion,
  quiltFabricCompatibility,
  ignoreModLoader,
}

@freezed
sealed class Tag with _$Tag {
  const factory Tag.dependencies() = Tag_Dependencies;
  const factory Tag.explicit() = Tag_Explicit;
  const factory Tag.custom(
    String field0,
  ) = Tag_Custom;
}
